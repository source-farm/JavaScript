
// JavaScript устроен так, что изо всех сил пытается выполнить любой код,
// который будет ему выдан, даже если этот код делает что-то странное:
console.log(42 * null);  // 0
console.log("10" - 1);   // 9
console.log("10" + 1);   // "101"
console.log("ten" * 1);  // NaN
console.log(false == 0); // true
console.log();

// Когда оператор применяется к значению "неправильного" типа JavaScript
// преобразует это значение к типу, которое ему нужно, используя правила,
// которые не всегда бывают очевидны. Например, "10" - 1 даёт 9, но "10" + 1
// выдаёт "101".
// Когда в число преобразуется значение, которое не совсем очевидно как
// преобразовывать, как например, "ten", получается значение NaN, и все
// последующие операции с NaN тоже дают NaN.

// Когда null или undefined оказываются задействованы в операторе равно(==),
// то результат будет равен true только если обе стороны являются null или
// undefined:
console.log(null == undefined); // true
console.log(null == 0); // false
console.log();

// Такое поведение часто бывает полезным, потому что если мы хотим узнать, что
// значение равно какому-то действительному значению мы можем сравнить его с
// null с помощью операторов == или !=.

// Если мы хотим в точности сравнивать значения без преобразования типов, то
// можно воспользоваться операторами === и !==:
console.log(false == 0);  // true
console.log(false === 0); // false
console.log(false != 0);  // false
console.log(false !== 0); // true

 
//------------------------------------------------------------------------------
// Массивы
//------------------------------------------------------------------------------

// Объявить массив можно так:
var listOfNumbers = [1, 2, 3];
console.log(listOfNumbers);

// Массив необъязательно должен хранить элементы одного и того типа.
// Индексирование начинается с 0:
console.log(listOfNumbers[0]);

// Размер массива можно узнать с помощью его свойства length:
console.log(listOfNumbers.length);

// Массив - это тоже объект, но только специализированный для работы с
// последовательностью данных.
console.log(typeof []);

// Для прохождения по элементам массива можно воспользоваться специальным
// видом цикла for:
for (let num of [2, 3, 5]) {
    console.log(num);
}
console.log();
 
//------------------------------------------------------------------------------
// Свойства
//------------------------------------------------------------------------------

// Почти все объекты JavaScript имеют свойства(properties). Исключением
// являются объекты null и undefined. Получить доступ к свойству можно, указав
// его название после . либо передав в виде строки в квадратных скобках после
// объекта:
console.log(listOfNumbers.length);
console.log(listOfNumbers["length"]);
console.log();
 
//------------------------------------------------------------------------------
// Методы
//------------------------------------------------------------------------------

// Если свойство объекта указывает на функцию, то такое свойство обычно
// называют методом. Например, методом является свойство log объекта console:
console.log("Doh");

// Примеры методов:
let doh = "Doh";
console.log(doh.toUpperCase());

let sequence = [1, 2, 3];
sequence.push(4);
sequence.push(5);
console.log(sequence);
console.log(sequence.pop());
console.log(sequence);
console.log();
 
//------------------------------------------------------------------------------
// Объекты
//------------------------------------------------------------------------------

// Значения типа объект являются группой произвольных свойств. Создавать
// объекты можно с помощью литерала объекта:
let day1 = {
    squirrel: false,
    events: ["work", "pizza"]
};
console.log(day1);

// Если название свойства не является правильным идентификатором или числом, то
// его необходимо заключать в кавычки:
let description = {
    work: "went to work",
    "touched tree": "touched"
};
console.log(description);

// Если попытаться получить доступ к свойству, которого нет в объекте, то будет
// возвращено значение undefined:
console.log(description.hello);

// Если присвоить значение свойству, которого ещё нет в объекте, то оно будет
// создано сразу на лету:
let id = {
    name: "Doe"
};
id.age = 13;
console.log(id.age);

// Удалить свойство можно с помощью оператора delete:
delete id.age;
console.log(id);

// Узнать есть ли свойство у объекта можно с помощью оператора in:
console.log("name" in id);
console.log("age" in id);

// Получить все свойства объекта можно с помощью метода Object.keys:
let point = {
    x: 0,
    y: 0,
    z: 0
};
console.log(Object.keys(point));
console.log();
 
//------------------------------------------------------------------------------
// Mutability
//------------------------------------------------------------------------------

// Значения простых типов как number, string и boolean являются неизменяемыми.
// Можно получить новые значения этих типов, но изменить те значения, что уже
// есть невозможно. Например, если у нас есть строка, её уже нельзя изменить:
// нельзя никакими действиями превратить "cat" в "rat".

// Объекты работают по-другому: их можно менять, задавая новые значения
// свойств. При сравнении казалось бы одинаковых объектов можно получить
// "неожиданные" результаты:
let obj1 = { value: 1 };
let obj2 = obj1;
let obj3 = { value: 1 };

console.log(obj1 == obj2); // true
console.log(obj1 == obj3); // false

obj1.value = 2;
console.log(obj2.value); // 2
console.log(obj3.value); // 1

// Связывания obj1 и obj2 указывают на один и тот же объект, поэтому при их
// сравнении мы получаем true. Объект obj3 эти совершенно другой объект,
// который живёт своей жизнью. Хотя он имеет те же свойства и их значения, что
// и объект obj1, при их сравнении мы получаем false. В JavaScript нет
// встроенных возможностей для глубокого сравнения: связывания, которые
// сравниваются с помощью == считаются равными только когда они указывают на
// один и тот же объект.

// Связывания могут быть изменяемыми или константными. Если при создании
// связывания использовать const, то это означает, что это связывание навсегда
// связано с указанным значением и нельзя его куда ли перенаправить. При этом
// объект, на который указывает это связывание, можно менять как угодно:
const score = { visitors: 0, home: 0 };
score.visitors = 13;
console.log(score);
// Ошибка.
//core = { visitors: 10, home: 10 };

//------------------------------------------------------------------------------
// Создание
//------------------------------------------------------------------------------

// JavaScript поддерживает регулярные выражения. Создать их можно либо
// с помощью конструктора либо используя специальный литерал регулярного
// выражения:

// Конструктор.
let re1 = new RegExp("pattern");
// Литерал.
let re2 = /pattern/;

// При использовании летерала для обозначения прямого слеша как части шаблона
// необходимо перед ним поставить обратный слеш. Перед некоторыми символами,
// которые имеют специальное значение в регулярных выражениях(?, + и др.) также
// необходимо ставить обратный слеш, чтобы они считались просто символом:
let eighteenPlus = /eighteen\+/;

//------------------------------------------------------------------------------
// Использование
//------------------------------------------------------------------------------

// С помощью метода test объекта регулярного можно узнать нашлось ли совпадение
// в переданном тексте:
console.log(re1.test("a pattern"));                    // true
console.log(re2.test("a regular expression pattern")); // true
console.log(eighteenPlus.test("eighteen+"));           // true
console.log();

//------------------------------------------------------------------------------
// Множество символов
//------------------------------------------------------------------------------

// В регулярных выражениях с помощью квадратных скобок можно указать множество
// символов в качестве шаблона:

// Проверка наличия в строке хотя бы одной цифры.
let reDigits = /[01234567890]/;
console.log(reDigits.test("in 1992"));         // true
console.log(reDigits.test("in last century")); // false
let reDigits2 = /[0-9]/; // То же самое, что и /[01234567890]/.
console.log(reDigits2.test("HAL9000"));        // true
console.log();

// С помощью знака '-' между символами можно указать диапазон. Поэтому и стало
// возможным использование шаблона [0-9] в примере выше. Символы внутри
// диапазона определяются в возрастающем порядке Unicode кодов от начального
// символа до конечного. Некоторые наборы символов имеют свои собственные
// обозначения. Например, цифры можно обозначить как \d вместо [0-9]. Есть и
// другие сокращения:
//
//     \d - цифра
//     \w - буква или число
//     \s - пробельный символ(пробел, перенос строки и др.)
//     \D - не цифра
//     \W - не буква и не число
//     \S - не пробельный символ
//     .  - любой символ, кроме переноса строки
//
// Пример:
let reDateTime = /\d\d-\d\d-\d\d\d\d \d\d:\d\d/;
console.log(reDateTime.test("01-01-1970 00:00"));  // true
console.log(reDateTime.test("01-1-1970 00:00"));   // false
console.log(reDateTime.test("01-jan-1970 00:00")); // false
console.log();

// Специальные символы внутри квадратных скобок теряют свой специальные смысл.
// Например, [.] - это рег. выражение для символа точки, а не любого символа,
// кроме переноса строки.
console.log(/[.]/.test("HELLO")); // false, т.к. символ точки не найден.
console.log();

// Инвертировать набор символов можно поставив символ '^' после [:
let reNotBinary = /[^01]/;
console.log(reNotBinary.test("0010101000111110")); // false
console.log(reNotBinary.test("2010101000111110")); // true
console.log();

//------------------------------------------------------------------------------
// Повторение части шаблона
//------------------------------------------------------------------------------

// С помощью символов +, * и ? можно повторить символ, который стоит перед
// ними:
//
//     + - повторить символ 1 или большее количество раз
//     * - повторить символ 0 или большее количество раз
//     ? - повторить символ 0 или 1 раз
//
// Примеры:
let reOneOrMoreDigit = /\d+/;
let reZeroOrMoreDigit = /\d*/;
let reNeighbor = /neighbou?r/;
console.log(reOneOrMoreDigit.test("at 6:00PM"));  // true
console.log(reOneOrMoreDigit.test("HELLO"));      // false
console.log(reZeroOrMoreDigit.test("at 6:00PM")); // true
console.log(reZeroOrMoreDigit.test("HELLO"));     // true
console.log(reNeighbor.test("neighbor"));         // true
console.log(reNeighbor.test("neighbour"));        // true
console.log();

// Точное количество совпадений можно указать с помощью числа в фигурных
// скобках. Например {4} означает повторить ровно 4 раза. Также внутри фигурных
// скобок можно указать мин. и макс. возможное количество совпадений:
// {min,max}. Можно также не указывать одну из границ. Например, {5,} означает
// повторить 5 или большее количество раз. Пример:
let reDateTime2 = /\d{1,2}-\d{1,2}-\d{4} \d{1,2}:\d{2}/;
console.log(reDateTime2.test("1-30-2003 8:45")); // true
console.log();

//------------------------------------------------------------------------------
// Группирование
//------------------------------------------------------------------------------

// Для того чтобы применить операторы как + или * к более чем одному символу
// можно использовать группирование:

// + внутри скобок применяется только к символу 'a'. + в конце применяется ко
// всему выражению hurra+.
let reHurra = /(hurra+)+/;
console.log(reHurra.test("hurraaaaaaa"));
console.log();

//------------------------------------------------------------------------------
// Регистр символов
//------------------------------------------------------------------------------

// Чтобы не учитывать регистр нужно добавить символ 'i' в конец регулярного
// выражения:
let reNoCase = /hello/i;
console.log(reNoCase.test("HELLO")); // true
console.log();

//------------------------------------------------------------------------------
// Группы совпадений
//------------------------------------------------------------------------------

// Регулярные выражения обладают методом exec, который позволяет получить более
// подробную информацию о совпадении(если совпадения нет, то возвращается null):
let match = /\d+/.exec("one two 42");
if (match) {
    console.log(match);
    console.log(match.index); // Место, где произошло совпадение.
} else {
    console.log("no match");
}

// С помощью скобок можно выделить отдельные группы совпадений. При этом
// первый элемент объекта, который возвращает exec, будет хранить всё
// совпадение, а далее будут идти группы совпадений, которые были найдены:
let reDayMonthYear = /(\d{1,2})-(\d{1,2})-(\d{4})/;
match = reDayMonthYear.exec("at 3-08-2014");
if (match) {
    console.log("Whole match: " + match[0]);
    console.log("day: " + match[1] + ", month: " + match[2] + ", year: " + match[3]);
}

// Если группа совпадений не найдена, то exec вернёт undefined:
match = console.log(/bad(ly)?/.exec("bad"));
if (match) {
    console.log(match[0]); // bad
    console.log(match[1]); // undefined
}

// Если совпадений группы было несколько, то exec найдёт самое последнее:
console.log(/(\d)+/.exec("123")[1]); // 3
console.log();

//------------------------------------------------------------------------------
// Начало и конец строки, поиск слов
//------------------------------------------------------------------------------

// Чтобы совпадение начиналось с начала строки и оканчивалось в её конце можно
// воспользоваться символами ^ и $ соответственно:
let reOnlyDigits = /^\d+$/;
console.log(reOnlyDigits.test("1234"));  // true
console.log(reOnlyDigits.test("a1234")); // false
console.log(reOnlyDigits.test(""));      // false
console.log();

// Для поиска текста только по границе слова можно воспользоваться маркерам \b:
let reCatWord = /\bcat\b/;
console.log(reCatWord.test("cat"));         // true
console.log(reCatWord.test("catANDdog"));   // false
console.log(reCatWord.test("cat and dog")); // true
console.log(reCatWord.test("caterpillar")); // false
console.log();

//------------------------------------------------------------------------------
// Выбор из нескольких вариантов
//------------------------------------------------------------------------------

// Символ '|' позволяет указать на возможность выбора варианта слева или справа
// от него в зависимости от того, что подходит:
let reAnimalCount = /\b\d+ (pig|cow|chicken)s?\b/;
console.log(reAnimalCount.test("12 cows"));  // true
console.log(reAnimalCount.test("2 horses")); // false
console.log(reAnimalCount.test("two pigs")); // false
console.log();

// Скобки помогают ограничить область действия '|'. Также следует обратить
// внимание, что вставка пробелов вокруг '|' означает поиск уже другого
// шаблона, который содержит пробел.

//------------------------------------------------------------------------------
// Метод replace
//------------------------------------------------------------------------------

// Строки обладают методом replace, с помощью которого можно заменить часть
// строки на другую:
console.log("papa".replace("p", "m"));

// Первый параметр этого метода может быть также и регулярным выражением. Если
// после регулярного выражения добавить символ 'g', то будут заменены все
// совпадения:
console.log("bbuu".replace(/[bu]/, "a"));  // abuu
console.log("bbuu".replace(/[bu]/g, "a")); // aaaa

// Можно также пользоваться и группами совпадений:
let people = "Liskov, Barbara\nMcCarthy, John\nWadler, Philip";
console.log(people.replace(/(\w+), (\w+)/g, "$2 $1")); // Замена местами имени и фамилии.

// В качестве второго параметра можно также передавать и функцию:
let agency = "the cia and fbi";
console.log(agency.replace(/\b(cia|fbi)\b/g, str => str.toUpperCase()));

//------------------------------------------------------------------------------
// Жадные операторы
//------------------------------------------------------------------------------

// Рассмотрим следующий код, который убирает многострочный комментарий из
// JavaScript кода:

let code = "1 /* a */+/* b */ 1";
let reNoComment = /\/\*[^]*\*\//g;
console.log(code.replace(reNoComment, ""));

// Комбинация [^] означает любой символ(. не подходит т.к. в неё не входит
// символ переноса строки). В результате выполнения этого кода мы получим
// "1  1", а не "1 + 1" как ожидали. Этого случилось из-за так называемого
// жадного поведения операторов +, *, ? и {}. Они пытаются захватить как можно
// больше символов, которые удовлетворяют регулярному выражению. В нашем случае
// выражение [^]* привело к тому, что пропустив первый */, который идёт за
// символом 'a', алгоритм пошёл ко второму */, который идёт после 'b'. Чтобы
// найти первое совпадение нужно после оператора ставить символ '?'(+?, *?, ??
// и {}?):
let reNotGreedNoComment = /\/\*[^]*?\*\//g;
console.log(code.replace(reNotGreedNoComment, ""));
console.log();

//------------------------------------------------------------------------------
// Динамическое создание регулярных выражений
//------------------------------------------------------------------------------

// Когда на этапе написания кода неизвестен точный вид регулярного выражения, то
// можно создать его динамически с помощью конструктора RegExp:
let name = "harry";
let text = "Harry is suspicious character.";
let reHarry = new RegExp("\\b(" + name + ")\\b", "gi"); // то же самое, что и /\b(harry)\b/gi
console.log(text.replace(reHarry, "_$1_"));
console.log();

//------------------------------------------------------------------------------
// Метод search
//------------------------------------------------------------------------------

// Методу indexOf нельзя передавать регулярное выражение. Но есть метод search,
// который поддерживает рег. выражения и как indefOf возвращает индекс того
// места, где было найдено первое совпадение(или -1 если нет совпадений):
console.log("  word".search(/\S/)); // 2
console.log("  ".search(/\S/));     // -1
